の〜〜と

真面目な文書ではない、だけどこれはとても重要

これは私がほしいと思ったから作ったものです
これは元々ゴミ箱に捨てるつもりでしたが、捨てるのが惜しくなったのでここに置いてます
私は日本人です、私のためのものです、コメントは日本人である私のためのものです
海外の皆さん、読みたければGoogle翻訳を使ってください

コメントのカテゴリの意味
　TODO: いつかやる、でもいまはめんどいからやらない
　FIXME: いつかなおす、だけどいまはめんどいからやらない
　HACK: 動きはあってんだけど意味不明 高速逆平方根なんて作らないけど

　WARN: 設計思想と合わない
　TOOBAD: 救いようがないゴミ設計
　PERF: 性能に悪影響あり 削れる負荷
　IDK: 調べりゃわかるかもしれんが調べることができていない
　しょうがない: しょうがない

　コメントは正規表現で消せます、自由に書いていきましょう

　 $ rg '(TODO|FIXME|HACK|WARN|TOOBAD|PERF|IDK|しょうがない):' -B 4 -A 3

パフォーマンス
　Vanilla.jsより遅くなってはいけません
　Vanilla.jsは高速です
　Vanilla.jsにも限界はあります
　Vanilla.jsの性能を最大限引き出すコードを書きましょう

　Reactはゴミです

JSDoc
　基本的にはｲﾝﾃﾘｾﾝｽがほしいだけ
　ついでに実行前の静的解析ができるなら良いことじゃないですか
　そして、ただのコメントだから実際に実行されるJavaScriptコードはそこにある

　TypeScriptはゴミです

　でも、実はこのプロジェクトで書いているJSDocは本来のJSDocではない

JavaScriptにおける型ベースのプログラム
　TypeScriptはゴミです
　ですが、TypeScriptの功績は認めています
　そのために、JSDocを書いています
　実際に書いているのはJSDocの”TypeScript拡張”で、本来のJSDocに無い機能を大量に使ってます
　例えば
　 * @import { Vector2 } from "./vector2"
　この@importというもの、これは公式のJSDocにはありません
　tscと、それを利用するVSCodeだから解釈できています
　 * @template T
　 * @typedef {T extends DrawNode<infer U> ? U : never} NodeOptions
　これなんて完全にアウトです
　inferなんてものTypeScriptじゃないと使えないし、型関数なんてTypeのScriptそのものです
　……だから、このプロジェクトで書いているのは”純粋なJavaScript”ではない

　……でも、”TypeScriptそのもの”でもない
　結局、処理は全てJavaScriptで、型定義は全て/** */で囲まれたJSDoc…… /* */は完全に単なる”コメント”です
　本当に、JSDocで書いた型はコードとして解釈されないんです
　tscもそれはわかっています
　だから、合ってない型に代入したらエラーが出ますし、不明な型に対して特定の型じゃないと使えないことをするとエラーになります

　しか〜し、JavaScriptにも型に関する構文はある
　typeofが一番有名でしょう
　let f = true;
　let a = f ? "1" : 1;  // aはfの分岐によりstring | number型

　// 型エラーが出る(stringとnumberのどちらかで存在しない関数を呼ぶため)
　a.repeat(10);
　a.toFixed(10);

　// typeofでチェックすれば型が固定され、エラーは出なくなる
　if (typeof a === "string")
　    a.repeat(10);
　if (typeof a === "number")
　    a.toFixed(10);
　でも、自分で定義したclassは、あくまでobject
　class c { something(n = 10) { return n; } }

　let f = true;
　let a = f ? "1" : new c();  // aはfの分岐によりstring | c型

　// 型エラーが出る(stringとcのどちらかで存在しない関数を呼ぶため)
　a.something(10);

　// typeofは特定の型しか返さない
　// 自分で定義したclassは全部"object"にひっくるめられるので、この条件式が型エラー
　if (typeof a === "c")
　    a.something(10);
　そんなときにはinstanceofを使います
　// instanceofはプロトタイプチェーンに目的の型があるかどうかをチェックする
　if (a instanceof c)
　    a.something(10);  // aはc型
　こうすれば、JavaScriptでも型を明示したコードを書くことができます

TypeScript
　さっきTypeScriptはゴミですと言いましたが、だからといって誰に対しても使用を禁止するのは道徳的によろしくありません

　なぜTypeScriptが嫌いなのか
　それは、ビルドが必要になるからです
　ビルドした結果ネイティブバイナリになって爆速になるんだったら許しますよ
　AssemblyScriptは喜んで書きましょう
　でも、結局変化する先はJavaScript
　なんならJavaScriptになった結果遅くなることもある
　enumのビルド結果を知ってますか？あんなものを見たら絶対に使いたくなくなりますよ
　そして、結局型は幻想
　ランタイムでの型の保証は存在しない
　なら、TypeScriptの安全性って何？

　型定義はちゃんとやってるんで、このライブラリはTypeScriptからでも使えるはずです
　ただしJavaScriptなので、allowJsをtrueにしないと読み込んでくれません
　雑なサンプルコードは長すぎるんで下に貼っときます

any
　ぜったいに潰す
　OffscreenCanvas→Canvasはギリゆるそう
　それ以外は、潰す

エコシステム化
　エコシステム化はしてはいけません
　DrawNodeは、いきなり単体でnewしても使えます
　ctxはいつでも変えられます

　const canvas = document.getElementById("my-canvas");
　const ctx = canvas.getContext("2d");

　const circle = new Circle({radius: 50, color: "red"});

　const start = performance.now();
　function update(now) {
　    const t = now - start;

　    ctx.reset();  // fillStyleやscale, rotationをリセット、ピクセルを全消去

　    // 通常のCanvas APIを使用した描画
　    ctx.fillStyle = "#0f08";
　    ctx.fillRect(0, 0, 30, 30);
　
　    // ライブラリを使用する
　    const snapshot = circle.getSnapshot(t);
　    snapshot.render(ctx);

　    requestAnimationFrame(update);
　}

　requestAnimationFrame(update);

　これだけで動く世界を壊してはいけません
　AIに「Canvas APIを使ったコードを書いて」と言って書いてもらったコードがそのまま動くようにしましょう
　AIはButterflyGraphを知りません
　AIは私を知りません

存在価値
　そんなもの元からありません
　ライブラリなんてぶっちゃけなくても良いんです
　ただ、それをちょっとだけ便利にした……それだけのことです
　ESNext標準機能だけでリッチなウェブサイトは作れるでしょ？多少大変だけど

　このライブラリは空気です
　あって当たり前だけど、実は標準機能じゃなかった
　jQuery, JSZip, Pythonで言えばrequestsのような立ち位置
　「そんな本気のものじゃないけど、素材の味そのままはちょっとつらい」
　そのときに、いつでも捨てられてしまう無価値な踏み台になる
　そんなものになりたい

WebGL
　Canvas APIには勝てません
　使いやすさもパフォーマンスも意味わかんないくらい強い
　Canvas APIはWebブラウザーというOSの特権システムコールです

BufferedContainer
　じつは、ButterflyGraphの名前の由来はこれです
　なんとなくbufferとbutterflyって似てるでしょ？それだけの理由
　しかしBufferedContainerがこのライブラリを大きく変化させたのも事実
　BufferedContainerは非常に重い
　そう、Vanilla.jsより遅くなるという最悪の事態に近づいてしまうんです
　だからどうにかして軽くしようと必死で最適化をしました

　・requestRecreate(reason)による内容変化の通知
　　これは、不要なバッファの再描画を避けて、同じ内容の再レンダリングを避けるためです
　・DrawNode.with(options)とconstructor(options, oldNode)による内部オブジェクトの引き継ぎ
　　これは、とんでもなく高価なオブジェクトであるOffscreenCanvasを使い回せるようにするためです

　そのほかにも色々なことがありました、もうよく覚えていませんが

　しかし、BufferedContainerは”特別な存在”であり、”ごく一般的な存在”でもあります
　BufferedContainerのdraw(ctx)関数では

　const transform = ctx.getTransform();
　const canvasWidth = ctx.canvas.width;
　const canvasHeight = ctx.canvas.height;

　このようにして、何も制限されることなくCanvasの状態を参照しています
　普通はこのようなことは許されないでしょう

　ですが、このライブラリは違います、何も制限がありません
　BufferedContainerのこの暴挙も、ライブラリ内部の特権ではありません
　ライブラリ外部で、ライブラリの利用者として存在しても何も不思議はないんです

　ctxは、だれでも公平に、全てが渡されています
　ctxは、だれでも公平に、自分で作り出すこともできます

　危険もあります、ただし、それ以上に無限の可能性があります
　その可能性は、使い倒せるようにしておきたい

　BufferedContainerがCanvas APIを本当に飛び出すための翼になるのは、また別の話……

ButterflyGraphとは何か
　2026年にCanvas APIを使うという技術選定をしてしまい、その便利さと可用性に魅入られた人間が作った
　Canvas APIをCanvas APIのまま便利にするライブラリ

　Immidiate modeをRetained modeに形を変えさせて、アニメーション関数を宣言的にして、キャッシュ最適化もする
　そうすれば、まるでCanvas APIを使っていると思えないような、自然なコードを書くことが出来る


    const canvas = document.getElementById("my-canvas");
    if (!(canvas instanceof HTMLCanvasElement)) throw new Error("Canvas not found!!!!!")
    const renderer = new HTMLCanvasRenderer(canvas, true);

    const root = new BufferedContainer({
        width: canvas.width,
        height: canvas.height,
    });

    let textObj;
    const content = new Container({
        anchor: Anchor.centre,
        origin: Anchor.centre,
        children: [
            new Circle({
                x: 50, y: 50,
                color: "#af2", radius: 100
            }),
            new Rectangle({
                x: 30, y: 30,
                anchor: Anchor.centre,
                origin: Anchor.centre,
                width: 50, height: 150,
                rotation: -Math.PI / 3,
                color: new LinearGradient(
                    0, 0, 50, 80,
                    [
                        { position: 0, color: "blue" },
                        { position: 1, color: "purple" }
                    ]
                )
            }),
            textObj = new TextObject({
                x: 10, y: 10,
                origin: Anchor.right,
                font: "50px serif",
                fillStyle: "black", strokeStyle: "yellow",
                fill: true, strokeWidth: 2,
                text: "Hello Canvas API!",
                showBounds: true  // 描画範囲を薄いピンク色で視覚化
            }),
        ]
    });
    root.addChild(content);

    const anim = content.registerAnimationFor("rotation", (value) => value * Math.PI * 2);
    anim.to(3, 3000)
        .delay(500)
        .easeOut(1, 1000)
        .delay(200)
        .easeInOutQuad(0, 1000);


    const textAnim = textObj.registerAnimationFor("text", (value) => (value / 1000).toFixed(3))
    textAnim.to(10 ** 5, 10 ** 5)

    function update(now) {
        const snapshot = root.getSnapshot(now);
        renderer.render(snapshot);

        requestAnimationFrame(update);
    }

    requestAnimationFrame(update);

　ね？簡単でしょ？
　……簡単じゃないって？まぁ、それは個人の感覚だからなんとも…………

TypeScriptで書いたときのサンプルコード
　私はTSを書いたことがない人間なので、正しいTSかどうかの保証はしません
　ですが、一応これで型エラーは出ません

import { Container, GenericContainer } from "@core/Graphics/Containers/container";
import { DrawNode, DrawNodeOptions } from "@core/Graphics/drawNode";
import { DrawObject, DrawObjectOptions } from "@core/Graphics/drawObject";

type TestObjectOptions = DrawObjectOptions & {
    lineWidth?: number
}

type TestNodeOptions = Omit<DrawNodeOptions, "strokeStyle"> & {
    strokeStyle: Exclude<DrawNodeOptions["strokeStyle"], undefined>,
    lineWidth: number
}

class TestObject extends DrawObject<TestNode> {
    lineWidth: number;
    constructor(options: Partial<TestObjectOptions> = {}) {
        super(options);

        this.lineWidth = options.lineWidth ?? 0;
    }

    calculateOptions(t: number): TestNodeOptions {
        const options = super.calculateOptions(t);
        return {
            ...options,
            strokeStyle: this.getStyle(this.strokeStyle),
            lineWidth: this.lineWidth
        }
    }

    createSnapshot(t: number): TestNode {
        const options = this.calculateOptions(t);
        return this.cachedNode?.with(options) ?? new TestNode(options);
    }
}

class TestNode extends DrawNode<TestNodeOptions> {
    #lineWidth: number;
    #path: Path2D;
    constructor(options: TestNodeOptions, oldNode: TestNode | null = null) {
        super(options, oldNode);

        this.#lineWidth = options.lineWidth;

        if (
            oldNode instanceof TestNode &&
            oldNode.width === options.width && oldNode.height === options.height) {
            this.#path = oldNode.#path;
        } else {
            const cx: number = options.width / 2;
            const cy: number = options.height / 2;
            const r: number = Math.min(cx, cy) / 2;

            const path: Path2D = new Path2D();
            path.moveTo(cx, 0); path.lineTo(cx, options.height);
            path.moveTo(0, cy); path.lineTo(options.width, cy);
            path.arc(cx, cy, r, 0, Math.PI * 2);

            this.#path = path;
        }
    }

    with(options: Partial<TestNodeOptions>): TestNode {
        if (this.constructor !== TestNode)
            throw new Error(`The ${this.constructor.name}.with(options) is not implemented.`);

        return new TestNode({...this.options, ...options});
    }

    draw(ctx: CanvasRenderingContext2D): void {
        this._setStrokeStyle(ctx);
        ctx.lineWidth = this.#lineWidth;
        ctx.stroke(this.#path);
    }
}

const root: GenericContainer = new Container();
const obj: TestObject = new TestObject({width: 10, height: 10, lineWidth: 1});
root.addChild(obj);
