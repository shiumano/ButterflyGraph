の〜〜と

真面目な文書ではない、だけどこれはとても重要

これは私がほしいと思ったから作ったものです
これは元々ゴミ箱に捨てるつもりでしたが、捨てるのが惜しくなったのでここに置いてます
私は日本人です、私のためのものです、コメントは日本人である私のためのものです
海外の皆さん、読みたければGoogle翻訳を使ってください

コメントのカテゴリの意味
　TODO: いつかやる、でもいまはめんどいからやらない
　FIXME: いつかなおす、だけどいまはめんどいからやらない
　HACK: 動きはあってんだけど意味不明 高速逆平方根なんて作らないけど

　WARN: 設計思想と合わない
　TOOBAD: 救いようがないゴミ設計
　PERF: 性能に悪影響あり 削れる負荷
　IDK: 調べりゃわかるかもしれんが調べることができていない
　しょうがない: しょうがない

　コメントは正規表現で消せます、自由に書いていきましょう

　 $ rg '(TODO|FIXME|HACK|WARN|TOOBAD|PERF|IDK|しょうがない):' -B 4 -A 3

パフォーマンス
　Vanilla.jsより遅くなってはいけません
　Vanilla.jsは高速です
　Vanilla.jsにも限界はあります
　Vanilla.jsの性能を最大限引き出すコードを書きましょう

　Reactはゴミです

JSDoc
　基本的にはｲﾝﾃﾘｾﾝｽがほしいだけ
　ついでに実行前の静的解析ができるなら良いことじゃないですか
　そして、ただのコメントだから実際に実行されるJavaScriptコードはそこにある

　TypeScriptはゴミです

any
　ぜったいに潰す
　OffscreenCanvas→Canvasはギリゆるそう
　DrawNode.optionsがanyなのは絶対に許してはいけない
　いつか、潰す

エコシステム化
　エコシステム化はしてはいけません
　DrawNodeは、いきなり単体でnewしても使えます
　ctxはいつでも変えられます

　const canvas = document.getElementById("my-canvas");
　const ctx = canvas.getContext("2d");

　const circle = new Circle({radius: 50, color: "red"});

　const start = performance.now();
　function update(now) {
　    const t = now - start;

　    ctx.reset();  // fillStyleやscale, rotationをリセット、ピクセルを全消去

　    // 通常のCanvas APIを使用した描画
　    ctx.fillStyle = "#0f08";
　    ctx.fillRect(0, 0, 30, 30);
　
　    // ライブラリを使用する
　    const snapshot = circle.getSnapshot(t);
　    snapshot.render(ctx);

　    requestAnimationFrame(update);
　}

　requestAnimationFrame(update);

　これだけで動く世界を壊してはいけません
　AIに「Canvas APIを使ったコードを書いて」と言って書いてもらったコードがそのまま動くようにしましょう
　AIはButterflyGraphを知りません
　AIは私を知りません

存在価値
　そんなもの元からありません
　ライブラリなんてぶっちゃけなくても良いんです
　ただ、それをちょっとだけ便利にした……それだけのことです
　ESNext標準機能だけでリッチなウェブサイトは作れるでしょ？多少大変だけど

　このライブラリは空気です
　あって当たり前だけど、実は標準機能じゃなかった
　jQuery, JSZip, Pythonで言えばrequestsのような立ち位置
　「そんな本気のものじゃないけど、素材の味そのままはちょっとつらい」
　そのときに、いつでも捨てられてしまう無価値な踏み台になる
　そんなものになりたい

WebGL
　Canvas APIには勝てません
　使いやすさもパフォーマンスも意味わかんないくらい強い
　Canvas APIはWebブラウザーというOSの特権システムコールです

BufferedContainer
　じつは、ButterflyGraphの名前の由来はこれです
　なんとなくbufferとbutterflyって似てるでしょ？それだけの理由
　しかしBufferedContainerがこのライブラリを大きく変化させたのも事実
　BufferedContainerは非常に重い
　そう、Vanilla.jsより遅くなるという最悪の事態に近づいてしまうんです
　だからどうにかして軽くしようと必死で最適化をしました

　・requestRecreate(reason)による内容変化の通知
　　これは、不要なバッファの再描画を避けて、同じ内容の再レンダリングを避けるためです
　・DrawNode.with(options)とconstructor(options, oldNode)による内部オブジェクトの引き継ぎ
　　これは、とんでもなく高価なオブジェクトであるOffscreenCanvasを使い回せるようにするためです

　そのほかにも色々なことがありました、もうよく覚えていませんが

　しかし、BufferedContainerは”特別な存在”であり、”ごく一般的な存在”でもあります
　BufferedContainerのdraw(ctx)関数では

　const transform = ctx.getTransform();
　const canvasWidth = ctx.canvas.width;
　const canvasHeight = ctx.canvas.height;

　このようにして、何も制限されることなくCanvasの状態を参照しています
　普通はこのようなことは許されないでしょう

　ですが、このライブラリは違います、何も制限がありません
　BufferedContainerのこの暴挙も、ライブラリ内部の特権ではありません
　ライブラリ外部で、ライブラリの利用者として存在しても何も不思議はないんです

　ctxは、だれでも公平に、全てが渡されています
　ctxは、だれでも公平に、自分で作り出すこともできます

　危険もあります、ただし、それ以上に無限の可能性があります
　その可能性は、使い倒せるようにしておきたい

　BufferedContainerがCanvas APIを本当に飛び出すための翼になるのは、また別の話……
