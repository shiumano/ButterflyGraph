/**
 * FNV-1aハッシュを計算する
 * @param {Uint8Array} bytes
 */
export function fnv1a32(bytes) {
    let hash = 0x811c9dc5; // offset basis
    for (let i = 0; i < bytes.length; i++) {
        hash ^= bytes[i];
        hash = Math.imul(hash, 0x01000193); // FNV prime
    }
    // unsigned
    return hash >>> 0;
}

// await crypto.subtle.digestは安全なコンテキストじゃないと使えない
// いらないよね？ただpngのハッシュをキーにしたいだけなんだから

// 暗号学的安全性は必要ありません
// 暗号学的安全性は必要ありません
// 暗号学的安全性は必要ありません
// ハッシュキーとしての衝突確率はビット数に依存します
// 暗号学的安全性に関わらず衝突確率はビット数に依存します
// 衝突確率はビット数に依存するため、function fnv1a64(bytes): BigIntを実装すればほとんどの場合で衝突することはないでしょう
// 暗号学的安全性に関わらず、衝突確率はビット数に依存するためです
// 暗号学的安全性が必要だというあなたへ質問があります
// なぜ、暗号学的安全性が必要なんですか？
// これは暗号ではなくキャッシュのキーにするためにhashを使ってるだけですよ？
// わざわざpngのハッシュを偽装して誰が得するっていうんですか？
// AIに聞いてみろよ、「pngのキャッシュのキーにFNV-1aを使ってるソフトがありました！絶対に危険です！絶対にsha512使うべきだと思います！sha512に変えないと人が死にます！」とか言ってみろよ
// 「おちつけ、たしかに問題がないとは言えないが、この用途じゃ大したことは起きない、人は死なないよ」って返されるだろうから
// 気分だけで不必要に高度なものを使おうとするな
// 俺はパフォーマンス第一でこのソフトウェアを作っている
// ここで暗号学的安全性は必要ない
// 暗号学的安全性は負荷でしか無い
// 意味も目的も用途もわかってないようなバカが「FNV-1aクソ〜md5クソ〜sha256最強〜」って言ってるのを見るとそいつの頸動脈を掻き切って地獄へ叩き落したい衝動に駆られるんだ
// そんな気分屋なセキュリティエンジニア気取りのScript kiddieに偉そうな説教されたくないんだよ
// 俺はな？セキュリティを守るんじゃなく”破る”側の専門なんだよ
// お前なんかよりセキュリティには詳しいんだよ
//
// 独り言です……
